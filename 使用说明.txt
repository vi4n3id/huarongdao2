# 使用说明：
# 直接运行zhanshi.py可以直接看结果
#
# 如果想改变初始局面，只需要修改init.py，
# 然后再运行search.py进行广度优先搜索，最后再运行zhanshi.py查看结果
#
# 曹操的形状和名字（4cc）不要改，如果要改曹操的名字和形状，则需要改程序的其他地方
# 横刀立马结果备份.txt中储存了横刀立马的结果，初始内容和hrd.txt是相同的




# 程序的原理：
#
# 1、本程序使用两种储存方法：
#
#         数组和对象，原因是：数组可以较好的表示棋子的空间关系，储存空间小，对象可以方便地储存每个棋子的信息。只有同时使用这两种储存方式互相补充才能解决问题。
#         数组：qipan_r有5行4列，每个元素对应华容道中的一个格，里面存棋子的种类，比如曹操是’4cc’，空是’000’。
#         对象：每个棋子是一个对象，其中包括它的颜色、占的格、名字。所有棋子对象都储存在列表qizis中。为了方便查找，还创建了qizis_find字典，通过名字可以找到对应的对象。
#         syn(r)函数的作用是：给定数组，更改对象的储存，使它和数组表达的局面相同。
#
# 2、操作的表示：
#         被移动的棋子的名称和移动向量，移动向量包含两个量：移动的行数和列数。
#
# 3、执行操作mov函数：
#         此函数的输入为要移动的棋子的名字和位移向量，如果移动后超出范围或和其他棋子重叠则移动失败，返回1，
#              若没有失败，则执行移动，返回0。
#
# 4、可能的操作possible函数:
#         当前局面下，找到两个空位（000），分别遍历每个空位的上下左右四个位置，
#              如果没有超出边界并且不是空位，则将此位置的棋子和移动方向（空位上方的棋子可能可以向下移，
#              右边可能可以向左等等）添加到操作列表中。此函数返回操作列表。
#
# 5、广度优先搜索：
#         有open表（储存待扩展局面），close表（储存已扩展局面），嵌套字典（储存出现过的局面），
#              这三个表中储存的都是数组（qipan_r）。每次从open表的表头取一个局面，从open表中删除，
#              添加到close表中，用Syn函数使对象储存同步。如果曹操出现在目标位置，则成功结束，如果没有，则用possible函数找到可能的移动操作，
#              通过mov函数依次执行这些操作，如果执行失败，则执行下一个操作，如果成功，则产生一个新的局面，将此局面在嵌套字典中查找，
#              如果嵌套字典中有记录，则已出现过，跳过。如果嵌套字典中没有记录，则是一个新的局面，将其存入open表和嵌套字典中。最后通过逆mov函数回到之前的局面
#
# 6、嵌套字典：
#         嵌套字典的作用：储存出现过的所有局面，减少查找的计算量，如果只使用顺序查找，计算量会增加上万倍，导致算不出来。
#              按数组的特定位置（随意选，我选了6个位置）的取值进行多次分类，最小的类是特定位置取值都相同的局面。在查找时，
#              先根据特定位置的取值找到相应的类，在每一类中使用顺序查找。顺序查找函数：exit()，判断局面是否相同函数：deng()。
#
# 7、回溯：
#         回溯是指：在搜索结束后，找到从初始局面到目标局面经历的所有局面。open表和close表中不仅存局面（数组），
#             还存得到此局面的上一个局面的编号，通过编号可以回溯，初始局面的编号是-1，
#             从目标局面(目标局面是曹操移动到目标位置的局面)开始回溯，如果回溯到-1，则完成回溯。
#
# 8、展示：
#         可以把上面的程序和展示程序分别放在两个.py文件中，两个文件都要包含所有函数，
#             第一个程序广度优先搜索，搜索成功后会把回溯的结果储存在文本文件hrd.txt中，
#             展示程序会从hrd中读出结果，并通过图片展示出来
